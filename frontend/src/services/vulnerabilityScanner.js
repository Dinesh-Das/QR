/**
 * Automated Security Vulnerability Scanner
 * 
 * Performs automated security scans to detect common vulnerabilities
 * and security misconfigurations in the frontend application.
 * 
 * @module VulnerabilityScanner
 * @since 1.0.0
 * @author QRMFG Security Team
 */

import { securityMonitoring, SECURITY_EVENT_TYPES, SECURITY_SEVERITY } from './securityMonitoring';

/**
 * Vulnerability Types
 */
export const VULNERABILITY_TYPES = {
  // Storage Security
  INSECURE_STORAGE: 'INSECURE_STORAGE',
  SENSITIVE_DATA_EXPOSURE: 'SENSITIVE_DATA_EXPOSURE',
  
  // Authentication & Authorization
  WEAK_SESSION_MANAGEMENT: 'WEAK_SESSION_MANAGEMENT',
  MISSING_CSRF_PROTECTION: 'MISSING_CSRF_PROTECTION',
  
  // Input Validation
  MISSING_INPUT_VALIDATION: 'MISSING_INPUT_VALIDATION',
  XSS_VULNERABILITY: 'XSS_VULNERABILITY',
  
  // Configuration
  INSECURE_CONFIGURATION: 'INSECURE_CONFIGURATION',
  DEBUG_MODE_ENABLED: 'DEBUG_MODE_ENABLED',
  
  // Network Security
  INSECURE_COMMUNICATION: 'INSECURE_COMMUNICATION',
  MISSING_SECURITY_HEADERS: 'MISSING_SECURITY_HEADERS',
  
  // Dependencies
  VULNERABLE_DEPENDENCIES: 'VULNERABLE_DEPENDENCIES',
  OUTDATED_LIBRARIES: 'OUTDATED_LIBRARIES'
};

/**
 * Vulnerability Scanner Service
 */
export class VulnerabilityScanner {
  constructor() {
    this.scanResults = [];
    this.lastScanTime = null;
    this.isScanning = false;
  }

  /**
   * Run comprehensive security scan
   * @returns {Promise<Object>} Scan results
   */
  async runComprehensiveScan() {
    if (this.isScanning) {
      throw new Error('Scan already in progress');
    }

    this.isScanning = true;
    this.scanResults = [];
    this.lastScanTime = new Date().toISOString();

    try {
      console.log('[Security Scanner] Starting comprehensive security scan...');

      // Run all security checks
      await Promise.all([
        this.scanStorageSecurity(),
        this.scanAuthenticationSecurity(),
        this.scanInputValidation(),
        this.scanConfigurationSecurity(),
        this.scanNetworkSecurity(),
        this.scanDependencySecurity(),
        this.scanDOMSecurity(),
        this.scanCSPCompliance()
      ]);

      // Generate scan summary
      const scanSummary = this.generateScanSummary();

      // Log scan completion
      securityMonitoring.logSecurityEvent(
        'VULNERABILITY_SCAN_COMPLETED',
        {
          totalVulnerabilities: this.scanResults.length,
          criticalCount: this.scanResults.filter(v => v.severity === 'CRITICAL').length,
          highCount: this.scanResults.filter(v => v.severity === 'HIGH').length,
          mediumCount: this.scanResults.filter(v => v.severity === 'MEDIUM').length,
          lowCount: this.scanResults.filter(v => v.severity === 'LOW').length,
          scanDuration: Date.now() - new Date(this.lastScanTime).getTime()
        },
        SECURITY_SEVERITY.LOW
      );

      return scanSummary;

    } catch (error) {
      console.error('[Security Scanner] Scan failed:', error);
      
      securityMonitoring.logSecurityEvent(
        'VULNERABILITY_SCAN_FAILED',
        { error: error.message },
        SECURITY_SEVERITY.MEDIUM
      );
      
      throw error;
    } finally {
      this.isScanning = false;
    }
  }

  /**
   * Scan storage security
   */
  async scanStorageSecurity() {
    console.log('[Security Scanner] Scanning storage security...');

    // Check for sensitive data in localStorage
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        
        if (this.containsSensitiveData(key, value)) {
          this.addVulnerability({
            type: VULNERABILITY_TYPES.SENSITIVE_DATA_EXPOSURE,
            severity: 'HIGH',
            title: 'Sensitive Data in localStorage',
            description: `Sensitive data found in localStorage key: ${key}`,
            recommendation: 'Move sensitive data to secure storage or encrypt before storing',
            location: 'localStorage',
            evidence: { key, valueLength: value?.length || 0 }
          });
        }
      }
    } catch (error) {
      console.warn('[Security Scanner] Could not scan localStorage:', error);
    }

    // Check for sensitive data in sessionStorage
    try {
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        const value = sessionStorage.getItem(key);
        
        if (this.containsSensitiveData(key, value)) {
          this.addVulnerability({
            type: VULNERABILITY_TYPES.SENSITIVE_DATA_EXPOSURE,
            severity: 'MEDIUM',
            title: 'Sensitive Data in sessionStorage',
            description: `Sensitive data found in sessionStorage key: ${key}`,
            recommendation: 'Encrypt sensitive data before storing in sessionStorage',
            location: 'sessionStorage',
            evidence: { key, valueLength: value?.length || 0 }
          });
        }
      }
    } catch (error) {
      console.warn('[Security Scanner] Could not scan sessionStorage:', error);
    }

    // Check for unencrypted tokens
    const token = localStorage.getItem('token') || sessionStorage.getItem('token');
    if (token && !this.isTokenEncrypted(token)) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.INSECURE_STORAGE,
        severity: 'CRITICAL',
        title: 'Unencrypted Authentication Token',
        description: 'Authentication token is stored without encryption',
        recommendation: 'Use SecureTokenStorage to encrypt tokens before storage',
        location: 'Browser Storage',
        evidence: { tokenFound: true, encrypted: false }
      });
    }
  }

  /**
   * Scan authentication security
   */
  async scanAuthenticationSecurity() {
    console.log('[Security Scanner] Scanning authentication security...');

    // Check session timeout configuration
    const sessionTimeout = this.getSessionTimeout();
    if (!sessionTimeout || sessionTimeout > 30 * 60 * 1000) { // 30 minutes
      this.addVulnerability({
        type: VULNERABILITY_TYPES.WEAK_SESSION_MANAGEMENT,
        severity: 'MEDIUM',
        title: 'Long Session Timeout',
        description: 'Session timeout is too long or not configured',
        recommendation: 'Set session timeout to maximum 30 minutes',
        location: 'Session Management',
        evidence: { currentTimeout: sessionTimeout }
      });
    }

    // Check for CSRF token implementation
    if (!this.hasCSRFProtection()) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.MISSING_CSRF_PROTECTION,
        severity: 'HIGH',
        title: 'Missing CSRF Protection',
        description: 'No CSRF token implementation detected',
        recommendation: 'Implement CSRF tokens for state-changing requests',
        location: 'Request Headers',
        evidence: { csrfTokenFound: false }
      });
    }

    // Check password policy enforcement
    if (!this.hasStrongPasswordPolicy()) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.WEAK_SESSION_MANAGEMENT,
        severity: 'MEDIUM',
        title: 'Weak Password Policy',
        description: 'Password policy is not enforced or is too weak',
        recommendation: 'Implement strong password requirements (8+ chars, mixed case, numbers, symbols)',
        location: 'Authentication Forms',
        evidence: { passwordPolicyEnforced: false }
      });
    }
  }

  /**
   * Scan input validation
   */
  async scanInputValidation() {
    console.log('[Security Scanner] Scanning input validation...');

    // Check for forms without validation
    const forms = document.querySelectorAll('form');
    let unvalidatedForms = 0;

    forms.forEach((form, index) => {
      const inputs = form.querySelectorAll('input, textarea, select');
      let hasValidation = false;

      inputs.forEach(input => {
        if (input.hasAttribute('required') || 
            input.hasAttribute('pattern') || 
            input.hasAttribute('minlength') || 
            input.hasAttribute('maxlength')) {
          hasValidation = true;
        }
      });

      if (!hasValidation && inputs.length > 0) {
        unvalidatedForms++;
      }
    });

    if (unvalidatedForms > 0) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.MISSING_INPUT_VALIDATION,
        severity: 'HIGH',
        title: 'Forms Without Input Validation',
        description: `${unvalidatedForms} form(s) found without proper input validation`,
        recommendation: 'Add client-side and server-side input validation to all forms',
        location: 'Form Elements',
        evidence: { unvalidatedForms, totalForms: forms.length }
      });
    }

    // Check for potential XSS vulnerabilities
    const dangerousElements = document.querySelectorAll('[onclick], [onload], [onerror]');
    if (dangerousElements.length > 0) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.XSS_VULNERABILITY,
        severity: 'HIGH',
        title: 'Inline Event Handlers Detected',
        description: `${dangerousElements.length} element(s) with inline event handlers found`,
        recommendation: 'Remove inline event handlers and use addEventListener instead',
        location: 'DOM Elements',
        evidence: { dangerousElements: dangerousElements.length }
      });
    }
  }

  /**
   * Scan configuration security
   */
  async scanConfigurationSecurity() {
    console.log('[Security Scanner] Scanning configuration security...');

    // Check if debug mode is enabled in production
    if (process.env.NODE_ENV === 'production' && this.isDebugModeEnabled()) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.DEBUG_MODE_ENABLED,
        severity: 'HIGH',
        title: 'Debug Mode Enabled in Production',
        description: 'Debug mode is enabled in production environment',
        recommendation: 'Disable debug mode in production builds',
        location: 'Application Configuration',
        evidence: { nodeEnv: process.env.NODE_ENV, debugEnabled: true }
      });
    }

    // Check for exposed environment variables
    const exposedVars = this.getExposedEnvironmentVariables();
    if (exposedVars.length > 0) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.INSECURE_CONFIGURATION,
        severity: 'MEDIUM',
        title: 'Exposed Environment Variables',
        description: `${exposedVars.length} potentially sensitive environment variable(s) exposed`,
        recommendation: 'Review and secure environment variable exposure',
        location: 'Environment Configuration',
        evidence: { exposedVariables: exposedVars }
      });
    }

    // Check console logging in production
    if (process.env.NODE_ENV === 'production' && this.hasConsoleLogging()) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.SENSITIVE_DATA_EXPOSURE,
        severity: 'LOW',
        title: 'Console Logging in Production',
        description: 'Console logging detected in production build',
        recommendation: 'Remove or disable console logging in production',
        location: 'Application Code',
        evidence: { consoleLoggingFound: true }
      });
    }
  }

  /**
   * Scan network security
   */
  async scanNetworkSecurity() {
    console.log('[Security Scanner] Scanning network security...');

    // Check if HTTPS is enforced
    if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.INSECURE_COMMUNICATION,
        severity: 'CRITICAL',
        title: 'Insecure HTTP Connection',
        description: 'Application is not using HTTPS',
        recommendation: 'Enforce HTTPS for all communications',
        location: 'Network Protocol',
        evidence: { protocol: window.location.protocol, hostname: window.location.hostname }
      });
    }

    // Check for mixed content
    const mixedContentElements = document.querySelectorAll('img[src^="http:"], script[src^="http:"], link[href^="http:"]');
    if (mixedContentElements.length > 0) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.INSECURE_COMMUNICATION,
        severity: 'HIGH',
        title: 'Mixed Content Detected',
        description: `${mixedContentElements.length} element(s) loading content over HTTP`,
        recommendation: 'Update all resource URLs to use HTTPS',
        location: 'Resource Loading',
        evidence: { mixedContentElements: mixedContentElements.length }
      });
    }

    // Check security headers (simulated - would need server-side check in real implementation)
    const securityHeaders = await this.checkSecurityHeaders();
    if (securityHeaders.missing.length > 0) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.MISSING_SECURITY_HEADERS,
        severity: 'MEDIUM',
        title: 'Missing Security Headers',
        description: `Missing security headers: ${securityHeaders.missing.join(', ')}`,
        recommendation: 'Configure server to send all required security headers',
        location: 'HTTP Headers',
        evidence: { missingHeaders: securityHeaders.missing }
      });
    }
  }

  /**
   * Scan dependency security
   */
  async scanDependencySecurity() {
    console.log('[Security Scanner] Scanning dependency security...');

    // This would typically require access to package.json and vulnerability databases
    // For now, we'll simulate basic checks
    
    // Check for known vulnerable patterns in loaded scripts
    const scripts = document.querySelectorAll('script[src]');
    const potentiallyVulnerable = [];

    scripts.forEach(script => {
      const src = script.src;
      // Check for old jQuery versions (example)
      if (src.includes('jquery') && (src.includes('1.') || src.includes('2.'))) {
        potentiallyVulnerable.push(src);
      }
    });

    if (potentiallyVulnerable.length > 0) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.VULNERABLE_DEPENDENCIES,
        severity: 'HIGH',
        title: 'Potentially Vulnerable Dependencies',
        description: `${potentiallyVulnerable.length} potentially vulnerable script(s) detected`,
        recommendation: 'Update to latest secure versions of all dependencies',
        location: 'Script Dependencies',
        evidence: { vulnerableScripts: potentiallyVulnerable }
      });
    }
  }

  /**
   * Scan DOM security
   */
  async scanDOMSecurity() {
    console.log('[Security Scanner] Scanning DOM security...');

    // Check for dangerous innerHTML usage
    const elementsWithInnerHTML = document.querySelectorAll('*');
    let dangerousInnerHTML = 0;

    // This is a simplified check - in practice, you'd need to analyze the actual code
    elementsWithInnerHTML.forEach(element => {
      if (element.innerHTML && element.innerHTML.includes('<script>')) {
        dangerousInnerHTML++;
      }
    });

    if (dangerousInnerHTML > 0) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.XSS_VULNERABILITY,
        severity: 'CRITICAL',
        title: 'Dangerous innerHTML Usage',
        description: `${dangerousInnerHTML} element(s) with potentially dangerous innerHTML`,
        recommendation: 'Use textContent or sanitize HTML before setting innerHTML',
        location: 'DOM Manipulation',
        evidence: { dangerousElements: dangerousInnerHTML }
      });
    }

    // Check for eval() usage (would need static analysis in practice)
    if (window.eval && typeof window.eval === 'function') {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.XSS_VULNERABILITY,
        severity: 'HIGH',
        title: 'eval() Function Available',
        description: 'eval() function is available and could be exploited',
        recommendation: 'Avoid using eval() and consider Content Security Policy',
        location: 'JavaScript Environment',
        evidence: { evalAvailable: true }
      });
    }
  }

  /**
   * Scan CSP compliance
   */
  async scanCSPCompliance() {
    console.log('[Security Scanner] Scanning CSP compliance...');

    // Check if CSP header is present
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const hasCsp = cspMeta !== null;

    if (!hasCsp) {
      this.addVulnerability({
        type: VULNERABILITY_TYPES.MISSING_SECURITY_HEADERS,
        severity: 'HIGH',
        title: 'Missing Content Security Policy',
        description: 'No Content Security Policy (CSP) header detected',
        recommendation: 'Implement a strict Content Security Policy',
        location: 'HTTP Headers',
        evidence: { cspPresent: false }
      });
    } else {
      // Analyze CSP policy for weaknesses
      const cspContent = cspMeta.getAttribute('content');
      if (cspContent && cspContent.includes('unsafe-inline')) {
        this.addVulnerability({
          type: VULNERABILITY_TYPES.INSECURE_CONFIGURATION,
          severity: 'MEDIUM',
          title: 'Weak Content Security Policy',
          description: 'CSP allows unsafe-inline which reduces security',
          recommendation: 'Remove unsafe-inline from CSP and use nonces or hashes',
          location: 'CSP Configuration',
          evidence: { cspContent: cspContent.substring(0, 100) }
        });
      }
    }
  }

  /**
   * Helper methods
   */
  containsSensitiveData(key, value) {
    const sensitivePatterns = [
      /password/i,
      /secret/i,
      /api[_-]?key/i,
      /access[_-]?token/i,
      /private[_-]?key/i,
      /credit[_-]?card/i,
      /ssn/i,
      /social[_-]?security/i
    ];

    const keyLower = key.toLowerCase();
    const valueLower = (value || '').toLowerCase();

    return sensitivePatterns.some(pattern => 
      pattern.test(keyLower) || pattern.test(valueLower)
    );
  }

  isTokenEncrypted(token) {
    // Simple check - encrypted tokens wouldn't be valid JWT format
    try {
      const parts = token.split('.');
      if (parts.length === 3) {
        // Looks like a JWT - probably not encrypted
        return false;
      }
      return true; // Assume encrypted if not JWT format
    } catch {
      return true; // Assume encrypted if can't parse
    }
  }

  getSessionTimeout() {
    // This would need to be implemented based on your session management
    return null;
  }

  hasCSRFProtection() {
    // Check for CSRF token in meta tags or forms
    const csrfMeta = document.querySelector('meta[name="csrf-token"]');
    const csrfInputs = document.querySelectorAll('input[name="_token"], input[name="csrf_token"]');
    return csrfMeta !== null || csrfInputs.length > 0;
  }

  hasStrongPasswordPolicy() {
    // Check if password inputs have strong validation patterns
    const passwordInputs = document.querySelectorAll('input[type="password"]');
    return Array.from(passwordInputs).some(input => {
      const pattern = input.getAttribute('pattern');
      return pattern && pattern.length > 20; // Assume complex pattern means strong policy
    });
  }

  isDebugModeEnabled() {
    // Check for debug indicators
    return window.console && 
           (window.localStorage.getItem('debug') === 'true' || 
            window.location.search.includes('debug=true'));
  }

  getExposedEnvironmentVariables() {
    const exposed = [];
    const sensitiveVarPatterns = [
      /api[_-]?key/i,
      /secret/i,
      /password/i,
      /private/i,
      /token/i
    ];

    // Check process.env if available
    if (typeof process !== 'undefined' && process.env) {
      Object.keys(process.env).forEach(key => {
        if (sensitiveVarPatterns.some(pattern => pattern.test(key))) {
          exposed.push(key);
        }
      });
    }

    return exposed;
  }

  hasConsoleLogging() {
    // This is a simplified check - would need static analysis in practice
    return window.console && typeof window.console.log === 'function';
  }

  async checkSecurityHeaders() {
    // This would need to be implemented with actual HTTP header checking
    // For now, return simulated results
    const requiredHeaders = [
      'X-Content-Type-Options',
      'X-Frame-Options',
      'X-XSS-Protection',
      'Strict-Transport-Security',
      'Content-Security-Policy'
    ];

    return {
      missing: requiredHeaders.filter(() => Math.random() > 0.7), // Simulate some missing
      present: []
    };
  }

  addVulnerability(vulnerability) {
    this.scanResults.push({
      id: `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      ...vulnerability
    });

    // Log critical and high severity vulnerabilities immediately
    if (vulnerability.severity === 'CRITICAL' || vulnerability.severity === 'HIGH') {
      securityMonitoring.logSecurityEvent(
        'VULNERABILITY_DETECTED',
        {
          vulnerabilityType: vulnerability.type,
          severity: vulnerability.severity,
          title: vulnerability.title,
          location: vulnerability.location
        },
        vulnerability.severity === 'CRITICAL' ? SECURITY_SEVERITY.CRITICAL : SECURITY_SEVERITY.HIGH
      );
    }
  }

  generateScanSummary() {
    const summary = {
      scanId: `scan_${Date.now()}`,
      timestamp: this.lastScanTime,
      totalVulnerabilities: this.scanResults.length,
      severityBreakdown: {
        critical: this.scanResults.filter(v => v.severity === 'CRITICAL').length,
        high: this.scanResults.filter(v => v.severity === 'HIGH').length,
        medium: this.scanResults.filter(v => v.severity === 'MEDIUM').length,
        low: this.scanResults.filter(v => v.severity === 'LOW').length
      },
      vulnerabilityTypes: {},
      recommendations: [],
      riskScore: 0
    };

    // Count vulnerability types
    this.scanResults.forEach(vuln => {
      summary.vulnerabilityTypes[vuln.type] = 
        (summary.vulnerabilityTypes[vuln.type] || 0) + 1;
    });

    // Calculate risk score (0-100)
    summary.riskScore = Math.min(100, 
      summary.severityBreakdown.critical * 25 +
      summary.severityBreakdown.high * 10 +
      summary.severityBreakdown.medium * 5 +
      summary.severityBreakdown.low * 1
    );

    // Generate top recommendations
    const criticalVulns = this.scanResults.filter(v => v.severity === 'CRITICAL');
    const highVulns = this.scanResults.filter(v => v.severity === 'HIGH');
    
    summary.recommendations = [
      ...criticalVulns.slice(0, 3).map(v => v.recommendation),
      ...highVulns.slice(0, 2).map(v => v.recommendation)
    ];

    return {
      summary,
      vulnerabilities: this.scanResults
    };
  }

  /**
   * Get scan results
   */
  getScanResults() {
    return {
      lastScanTime: this.lastScanTime,
      vulnerabilities: this.scanResults,
      summary: this.generateScanSummary().summary
    };
  }

  /**
   * Get vulnerabilities by severity
   */
  getVulnerabilitiesBySeverity(severity) {
    return this.scanResults.filter(v => v.severity === severity);
  }

  /**
   * Get vulnerabilities by type
   */
  getVulnerabilitiesByType(type) {
    return this.scanResults.filter(v => v.type === type);
  }
}

// Create singleton instance
export const vulnerabilityScanner = new VulnerabilityScanner();

export default vulnerabilityScanner;